---
sidebar_position: 50
---

import APITable from "@site/src/components/APITable";

# Development Conventions

This section provides general guidelines for development as well as their justification. It also deals with one of the
two hardest problems in computer science. Namely, naming.

---

## Naming Git Repositories

For all source code stored in Git repositories, services will typically namespace them under organizations, or projects
(e.g. GitHub and GitLab respectively). This means we do not need to add additional prefixes for our repositories.

To keep things easy to remember and associate with naming in code, we shall name all repositories based on the
abbreviation of the module they're for, and the repository description must continue the full module name at
the beginning.

For example, for `Unified Notification Hub` the repository name shall be:

```bash
unh
```

and a sample description would be:

```bash
Unified Notification Hub - supports email, sms, push notifications, and customized notification channels.
```

---

## Database

---

### Naming schemas

Services within our system might have to share database with other external services. The deployment configuration
is highly dependent on the project the system is ultimately deployed to. Because of this, all schemas shall be
prefixed with `aoh_` to avoid clashes in naming:

```bash
aoh_[repository name]
```

Example for a service named `Unified Notification Hub` with the repository abbreviation `unh`, the schema name shall be:

```bash
aoh_unh
```

See Also: [Git Repository Naming](#naming-git-repositories)

---

### Naming tables

Tables should be named after the entity they represent, in singular form (so a table representing notifications should
be called `notification`)

:::warning
That's notification WITHOUT the "S"!
:::

---

### Naming views

Views shall be prefixed with `v_`, this allows us to clearly see which tables are views. Database management UI's
would also typically sort tables by name, allowing all views to be grouped together neatly.

```bash
v_[view name]
```

Example:

```bash
v_notification_template
```

:::note
To be discussed: _naming materialized views_
:::

---

### Naming association tables

Association tables are commonly used to map the relationship between entities, especially for many-to-many
relationships. We'll use the simple, common covention of concatenating the two tables names and suffixing `_mapping`
behind.

```bash
[table 1]_[table 2]_mapping
```

Example:

```bash
user_notification_mapping
```

---

### Naming the database user

Direct database access for each service is via a unique database account. We do this instead of having a shared
account for the purpose having the ability to apply access control between services. We'll also have to namespace
this user account as we might share the database with other external services (as is often the case with
projects being deployed into existing infrastructure)

```bash
aoh_[repo name]_user
```

Example:

```bash
aoh_unh_user
```

See Also:

-   [Git Repository Naming](#naming-git-repositories)
-   [Naming Schemas](#naming-schemas)

---

### Mandatory Database Columns

The following fields (database columns) are mandatory and must be _NOT NULLABLE_.

```mdx-code-block
<APITable>
```

| Name         | Type        | Default             | Description                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| ------------ | ----------- | ------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `id`         | `uuid`      | `gen_random_uuid()` | We use a `uuid` as a primary key for all tables as a best practice. Having universally unique synthetic primary keys (as opposed to sequential ints) allows us to avoid a large class of common errors that might arise from unintended references. It is also better from a security perspective. If your module requires human-readable ID's, create another column for it and assign a unique constraint across that column + `tenant_id`. |
| `created_at` | `timestamp` | `now()`             | The UTC timestamp when this record was first created                                                                                                                                                                                                                                                                                                                                                                                          |
| `updated_at` | `timestamp` | `now()`             | The UTC timestamp when this record was last updated, use database triggers                                                                                                                                                                                                                                                                                                                                                                    |
| `created_by` | `text`      |                     | The reference to the user who created this record - do not apply database constraints                                                                                                                                                                                                                                                                                                                                                         |
| `updated_by` | `text`      |                     | The reference to the user who last modified this record - do not apply database constraints                                                                                                                                                                                                                                                                                                                                                   |
| `tenant_id`  | `text`      |                     | The reference to the tenant this row belongs to - do not apply database constraints                                                                                                                                                                                                                                                                                                                                                           |
| `occ_lock`   | `int`       | `0`                 | This integer must match on all update queries to ensure the user is not trying to update a row with outdated data (because another user might have already updated it, changing the number). The purpose is for optimistic currency control but you can think of this as a version number.                                                                                                                                                    |

```mdx-code-block
</APITable>
```

:::note
We only apply database constraints (e.g. foreign key constraints) when the reference is within the same service
(schema). This is to avoid coupling the services at the database level.
:::
:::warning PostgreSQL-specific types and functions
Some of the types and functions (like `gen_random_uuid`) might be a PostgreSQL-specific function. This will have to
vary based on your actual database product - use the appropriate alternatives instead.
:::

:::note TBD:
Discussion required to determine if the `soft delete` capability is required, and if the implementation should be via
extra fields or using archive tables.
:::

---

## API, Routes, and Endpoints

---

### Kubernetes Liveness and Readiness probes

All services must provide a `liveness` and `readiness` endpoint for Kubernetes to call. As a rule, we'll use
`livez` and `readyz` at the root path, which is common with Google's internal practices. However, certain frameworks
might already provide such endpoints for the same purpose, requiring you to utilize their naming scheme; in such a
scenario, you should stick with the framework's built-in endpoints (e.g. SpringBoot's `/actuator/health/liveness` &
`/actuator/health/readiness`).

-   Liveness Endpoint: `/livez`
-   Readiness Endpoint: `/readyz`

---

### Web Pages

The routing of web pages shall also be namespaced - first by the project, then by the module:

```
/[project]/[module]/...
```

Examples:

-   View all incidents page: `/aoh/incidents/`
-   View specific incident: `/aoh/incidents/inc-20240607-0001`
-   Dashboard page: `/aoh/dashboard?name=My+First+Dashboard`

---

### Response Format

As a standard for our system, we are adopting the following structure for the response payload for endpoints.
This type is defined in the `app.d.ts` as `HTTPResponseBody` and should be used to type all your API responses.

```jsx title="Example response body"
{
    data: {...}, // arbitrary format - recommend array for lists, object for individual records
    message: "...", // string
    sent_at: "", //iso8601
    errors: [ {
        message: "....", // string
        ...
    } ]
}
```

---

### Pagination

Querying for entities almost always requires pagination to pull data effectively (applications should almost never pull
an entire table of data).

Since pagination is a very common requirement, and different frameworks in different languages might support different
out-of-the-box implementations of pagination, we have to allow for some API to be flexible. However, the guidelines
to follow for paginated endpoints should be:

1. Pagination arguments should be URL query params
2. Requests: `page`, `size` and `sort` should be supported
    - `page` specifies what page the caller is currently at (the offset cursor) - only positive integers starting from 1
    - `size` specifies how many rows are in each page - only positive integers starting from 1
    - `sort` is a list of tuples containing `field` and `direction`
        - The `field` refers to the column to sort by
        - The `direction` refers to whether the sort is ascending or descending
            - `ASC` for ascending
            - `DESC` for descending (default)
3. Response: `data`, `page:{number}`, `page:{size}`, and `page:{totalRecords}` information should be returned
    - `data` is the result of the query
    - `number` is the current page of response
    - `size` is the number of records per page
    - `totalRecords` is the total number of records in the table

#### Request Pagination Params

```mdx-code-block
<APITable>
```

| Name   | Type            | Default           | Description                                                                                   |
| ------ | --------------- | ----------------- | --------------------------------------------------------------------------------------------- |
| `page` | `int`           | `1`               | The number of elements in each page. Invalid values will be ignored and default will be used  |
| `size` | `int`           | `10`              | The current page - pages start at 1. Invalid values will be ignored and default will be used  |
| `sort` | `string,string` | `created_at,DESC` | A list of sort columns and direction. Invalid values will be ignored and default will be used |

```mdx-code-block
</APITable>
```

#### Response Pagination Data

```mdx-code-block
<APITable>
```

| Name                     | Type  | Description                         |
| ------------------------ | ----- | ----------------------------------- |
| `page: { number }`       | `int` | The current page - pages start at 1 |
| `page: { size }`         | `int` | The number of elements in each page |
| `page: { totalRecords }` | `int` | the number of records in each page  |

```mdx-code-block
</APITable>
```

These fields need not strictly follow the same name (due to possible framework limitations), but the pagination API
should follow the specs listed above. The `page number`, `page size`, and `totalRecords` are typically required by the caller
in order to understand where the cursor is in relation to the rest of the table.

Example paginated API call:

```go title="Example request - page 1, default page size, and default sort"
example.agilopshub.com/user
```

```go title="Example request - page 3, 2 records per page, default sort"
example.agilopshub.com/user?page=3&size=2
```

```go title="Example request - page 3, 2 records per page, sort by username, descending"
example.agilopshub.com/user?&page=3&size=2&sort=username
```

```go title="Example request - page 3, 2 records per page, sort by email - descending, then sort by username - ascending"
example.agilopshub.com/user?page=3&size=2&sort=email,desc&sort=username,asc
```

```jsx title="Example response"
{
    "data": [
        {
            "username": "coolguy",
            "email": "iamcool@gmail.com"
        },
        {
            "username": "example",
            "email": "example@gmail.com"
        },
    ],
    "page": {
        "number": 3,
        "size": 2,
        "totalRecords": 35
    }
    ...
}
```

## Log levels

Logging is covered in the [Logging & Exception Handling](/docs/20_development/60_guidelines/20_logging_and_exception_handling.mdx)
guidelines section.

As a quick rule of thumb, use `DEBUG` log level to trace inputs (and potentially outputs) to function calls that are
useful for debugging the system, and leave these logs there. For `INFO` log level, use it to trace key events in the
system to indicate it is functionally correctly (such as a successful database connection event).
