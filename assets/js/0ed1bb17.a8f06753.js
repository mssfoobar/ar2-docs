"use strict";(self.webpackChunk_mssfoobar_docs=self.webpackChunk_mssfoobar_docs||[]).push([[523],{99981:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"modules/iams/development/authentication/id-token-access-token-refresh-tokens","title":"ID Token, Access Token, and Refresh Token","description":"As mentioned above, after user successful login to Keycloak, Keycloak will redirect user back to Web App Backend with authorization code which Web App Backend can use to exchange for ID Token, Access Token, and Refresh Token.","source":"@site/docs/modules/iams/development/authentication/id-token-access-token-refresh-tokens.md","sourceDirName":"modules/iams/development/authentication","slug":"/modules/iams/development/authentication/id-token-access-token-refresh-tokens","permalink":"/docs/docs/modules/iams/development/authentication/id-token-access-token-refresh-tokens","draft":false,"unlisted":false,"editUrl":"https://github.com/mssfoobar/docs/tree/main/docs/modules/iams/development/authentication/id-token-access-token-refresh-tokens.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"modulesSidebar","previous":{"title":"Browser Login using OpenID Connect (Authentication Flow)","permalink":"/docs/docs/modules/iams/development/authentication/browser-login"},"next":{"title":"Browser Logout using OpenID Logout Flow","permalink":"/docs/docs/modules/iams/development/authentication/browser-logout"}}');var i=s(74848),o=s(28453);const a={sidebar_position:3},c="ID Token, Access Token, and Refresh Token",r={},d=[{value:"ID Token",id:"id-token",level:2},{value:"Access Token",id:"access-token",level:2},{value:"Refresh Token",id:"refresh-token",level:2},{value:"Validate Access Token",id:"validate-access-token",level:2},{value:"Online Validation",id:"online-validation",level:3},{value:"Offline Validation",id:"offline-validation",level:3},{value:"Split Access Token into Sections",id:"split-access-token-into-sections",level:4},{value:"Validate the Signature",id:"validate-the-signature",level:4},{value:"Check Issue Date and Expiry Date",id:"check-issue-date-and-expiry-date",level:4}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"id-token-access-token-and-refresh-token",children:"ID Token, Access Token, and Refresh Token"})}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned above, after user successful login to Keycloak, Keycloak will redirect user back to Web App Backend with authorization code which Web App Backend can use to exchange for ",(0,i.jsx)(n.code,{children:"ID Token"}),", ",(0,i.jsx)(n.code,{children:"Access Token"}),", and ",(0,i.jsx)(n.code,{children:"Refresh Token"}),".\nAll the tokens returned by Keycloak are ",(0,i.jsx)(n.code,{children:"JWT"})," tokens. A ",(0,i.jsx)(n.code,{children:"JSON Web Token"})," (JWT) is a standard that defines a compact and secure way of transmitting data along with a signature between two parties. A JWT can contain any information in JSON form, also known as JWT claims. Typically, JWTs have an expiration time or exp claim, ensuring that they\u2019re valid for a particular duration."]}),"\n",(0,i.jsx)(n.h2,{id:"id-token",children:"ID Token"}),"\n",(0,i.jsxs)(n.p,{children:["OpenID Connect always issues ",(0,i.jsx)(n.code,{children:"ID tokens"})," along with ",(0,i.jsx)(n.code,{children:"access tokens"})," to provide compatibility with ",(0,i.jsx)(n.code,{children:"OAuth"})," and match the general tendency for authorizing identity."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ID token"})," carries personal information about end-users that authenticate on an OpenID Connect flow. In addition, this security token contains claims data about the user as saved with Keycloak."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ID token"})," is used to retrieve the user\u2019s basic profile information like name, username, and email, which is present in the Keycloak."]}),"\n",(0,i.jsxs)(n.p,{children:["::: caution\n",(0,i.jsx)(n.code,{children:"ID token"})," should ",(0,i.jsx)(n.strong,{children:"not"})," be used to gain access to backend APIs.\n:::"]}),"\n",(0,i.jsx)(n.h2,{id:"access-token",children:"Access Token"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Access tokens"})," are credentials used to access protected resources (i.e., backend APIs)."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Access tokens"})," are used as ",(0,i.jsx)(n.code,{children:"bearer"})," tokens. A bearer token means that the bearer (who holds the access token) can access authorized resources without further identification."]}),"\n",(0,i.jsx)(n.p,{children:"Because of this, it is important that bearer tokens be protected."}),"\n",(0,i.jsx)(n.p,{children:"These tokens usually have a short lifespan for security purposes. Typical lifespan is 5 minutes."}),"\n",(0,i.jsxs)(n.p,{children:["The lifespan can be change under the ",(0,i.jsx)(n.code,{children:"Realm setting"})," > ",(0,i.jsx)(n.code,{children:"Tokens"})," page in Keycloak Web Admin Console."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Access Token",src:s(80717).A+"",width:"777",height:"180"})}),"\n",(0,i.jsx)(n.p,{children:"When it expires, the new access token must be requested from Keycloak, either through authenticate again or using refresh token, which help to limit the exposure of the fact that it is a bearer token."}),"\n",(0,i.jsxs)(n.p,{children:["An access token is put in the Authorization header of the HTTP request to the backend API, it should be in the following format to ensure that the API that you are calling can verify it:\n",(0,i.jsx)(n.code,{children:"Bearer <access_token>"})]}),"\n",(0,i.jsx)(n.p,{children:"AGIL Ops Hub Web Framework has the mechanism to auto refresh the access token before it expires to minimize authorization error when invoking backend APIs."}),"\n",(0,i.jsx)(n.h2,{id:"refresh-token",children:"Refresh Token"}),"\n",(0,i.jsx)(n.p,{children:"This token is a long-lived token compared to the access token and is used to request a new access token in cases where it has expired. Hence, it can be considered as credentials used to obtain access tokens."}),"\n",(0,i.jsxs)(n.p,{children:["Typical lifespan of refresh token is typically ",(0,i.jsx)(n.code,{children:"30"})," minutes and the expiry time will get extended every time it is used to refresh the access token. However, it will not be extended beyond the SSO Session Max timing which typically set to ",(0,i.jsx)(n.code,{children:"10"})," hours."]}),"\n",(0,i.jsxs)(n.p,{children:["The lifespan of refresh token is configured in ",(0,i.jsx)(n.code,{children:"Realm setting"})," > ",(0,i.jsx)(n.code,{children:"Sessions page"}),", under the ",(0,i.jsx)(n.code,{children:"SSO Session Idle"})," and ",(0,i.jsx)(n.code,{children:"SSO Session Max fields"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The refresh token allows a new access token to be requested without needing the user to re-authenticate, thereby providing a seamless user experience."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Access Token",src:s(65351).A+"",width:"540",height:"204"})}),"\n",(0,i.jsx)(n.h2,{id:"validate-access-token",children:"Validate Access Token"}),"\n",(0,i.jsx)(n.p,{children:"As mentioned, Access Tokens are credentials used to access protected resources such as backend APIs. Hence, when received an Access Token alone with the request, the backend application will need to validate the Access Token and reject all requests with invalid or missing tokens."}),"\n",(0,i.jsx)(n.p,{children:"There are 2 ways to validate the Access Token:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Online validation"}),"\n",(0,i.jsx)(n.li,{children:"Offline validation"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"online-validation",children:"Online Validation"}),"\n",(0,i.jsx)(n.p,{children:"The simplest way to perform online validation is to invoke the Keycloak\u2019s Userinfo endpoint at:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"http(s)://<keycloak URL> /realms/<realm-name>/protocol/openid-connect/userinfo\n"})}),"\n",(0,i.jsxs)(n.p,{children:["where ",(0,i.jsx)(n.code,{children:"<keycloak URL>"})," is the URL to the Keycloak server and ",(0,i.jsx)(n.code,{children:"<realm-name>"})," is the name of the realm."]}),"\n",(0,i.jsx)(n.p,{children:"In the HTTP request, you need to pass the access token in the Authorization header. Below is an example of access that endpoint using postman:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Access Token",src:s(7649).A+"",width:"1024",height:"236"})}),"\n",(0,i.jsxs)(n.p,{children:["If the access token is valid, the endpoint will return the HTTP status ",(0,i.jsx)(n.code,{children:"200"})," and if the access token is invalid, the endpoint will return HTTP status ",(0,i.jsx)(n.code,{children:"401"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"::: Note\nsome literature will advise using the Token Introspect Endpoint to validate the token instead. However, do note that this endpoint can only be invoked by confidential clients. I.e., you will need to pass the client id and client secret as part of the request.\n:::"}),"\n",(0,i.jsx)(n.h3,{id:"offline-validation",children:"Offline Validation"}),"\n",(0,i.jsx)(n.p,{children:"Alternative to online validation is to do offline validation which is more efficient as it doesn\u2019t introduce another http/round trip for every validation."}),"\n",(0,i.jsx)(n.p,{children:"To offline validate access token, you need to perform the following steps:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Split the access token into its sections"}),"\n",(0,i.jsx)(n.li,{children:"Validate the signature of the access token"}),"\n",(0,i.jsx)(n.li,{children:"Check the issue date and expiry date in the token\u2019s claims"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"split-access-token-into-sections",children:"Split Access Token into Sections"}),"\n",(0,i.jsx)(n.p,{children:"As mentioned, access token is a standard JWT token which consists of the following sections:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Header"}),"\n",(0,i.jsx)(n.li,{children:"Payload (often referred to as body)"}),"\n",(0,i.jsx)(n.li,{children:"Signature"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Sections are represented as base64url-encoded strings separated by a period (\u2018.\u2019) delimiter. So, the first steps to validate the access token to split it into the 3 sections."}),"\n",(0,i.jsx)(n.p,{children:"The following is a Java code snippet to split the access token into 3 sections:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"String accessToken ='<access token string>';\nString [] parts = accessToken.split (\"\\\\.\");\n"})}),"\n",(0,i.jsx)(n.h4,{id:"validate-the-signature",children:"Validate the Signature"}),"\n",(0,i.jsx)(n.p,{children:"Next, we need to verify the integrity of the header and payload to ensure that they have not been altered by using the signature section."}),"\n",(0,i.jsx)(n.p,{children:"To begin verifying the payload and header, we need both the signature algorithm that was used originally to sign the token and the secret key. For Keycloak:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Signature algorithm is by default RS256"}),"\n",(0,i.jsx)(n.li,{children:"Secret Key is the public key of the realm, which can be obtains from the following endpoint:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"http(s)://<keycloak server URL>/realms/<realm name>\n"})}),"\n",(0,i.jsxs)(n.p,{children:["You should obtains respond similar to the followings with the public key in the ",(0,i.jsx)(n.code,{children:"public_key"})," field:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'{\n  "realm": "AOH",\n  "public_key": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7IaYbebl3fQ5ZaZBMlMe1kaTeVK0rfnn02bVWbHVudP0S513RdufxqosmKH0r/+QhXpZjfeEUfVrzKMe/NqJiVSv158gbPwX8ovqDTrPl/OEfROgvzMa+DM7HZxz9l1dSmPyXaG5TIl0CLLKibzDupp66/AuUluk4Z2fvBwujrJIQds6URGoVXhDqR136tqomgKU7UIB0dSgLK5ftO4SjPDRfij9+QNyyjF/kzTGqQmxeFEotmQrsGpGJPY7vYgHnlkSwLC7KM5JZwKex8uk6dVAOkM50rh3WxHIabH7h6m3Y5KpNVI/iS1e3clyaiE0iL1WCyByK2lXjVPjnSTQrwIDAQAB",\n  "token-service": "http://iams-keycloak.10.10.10.100.nip.io/realms/AOH/protocol/openid-connect",\n  "account-service": "http://iams-keycloak.10.10.10.100.nip.io/realms/AOH/account",\n  "tokens-not-before": 0\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The following is a Java code snippet using the Java JWT library from ",(0,i.jsx)(n.code,{children:"Auth0"})," to validate the signature:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'byte [] keyBytes = Base64.getDecoder().decode(JWTConstants.KEYCLOAK_PUBLIC_KEY);\nX509EncodedKeySpec encodedKeySpec = new X509EncodedKeySpec(keyBytes);\nKeyFactory factory = KeyFactory.getInstance("RSA");\nPublicKey pk = factory.generatePublic(encodedKeySpec);\nAlgorithm algorithm = Algorithm.RSA256((RSAPublicKey) pk, null);\nJWTVerifier verifier = JWT.require(algorithm).ignoreIssuedAt().build();\n\ntry {\nverifier.verify(accessToken);\n            return true;\n}\ncatch (JWTVerificationException e) {\nSystem.err.println(e);\n            return false;\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"check-issue-date-and-expiry-date",children:"Check Issue Date and Expiry Date"}),"\n",(0,i.jsx)(n.p,{children:"Finally, after determine that the signature of the access token is valid, the next step is to check that the access token not expired. To do that, you need to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Decode the payload of access token"}),"\n",(0,i.jsxs)(n.li,{children:["Check that the value of ",(0,i.jsx)(n.code,{children:"exp"})," doesn\u2019t exceed current timestamp"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The payload of the access token is encoded in base64."}),"\n",(0,i.jsx)(n.p,{children:"The following is a Java code snippet show how to decode the payload of the access token:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'String[] parts = accessToken.split("\\\\.");\nString decodedAccessToken  = new String(Base64.getUrlDecoder().decode(parts[1]));\n'})}),"\n",(0,i.jsx)(n.p,{children:"After decoded the access token, you should get a JSON string with structure similar to the followings:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'{\n  "exp" : 1725001351,\n  "iat" : 1725001051,\n  "jti" : "6087d61c-a81a-491c-b2e5-000643bfc3aa",\n  "iss" : "http://iams-keycloak.10.10.10.100.nip.io/realms/AOH",\n  "aud" : [ "realm-management", "account" ],\n  "sub" : "b6a62a0e-ab9f-4369-bc75-3e8bd2b5ddbb",\n  "typ" : "Bearer",\n  "azp" : "web-app",\n  "sid" : "e162ab8f-2f9c-461c-8c42-a713e7572cdb",\n  "acr" : "1",\n  "allowed-origins" : [ "http://localhost:3000" ],\n  "realm_access" : {\n    "roles" : [ "system-admin", "default-roles-aoh", "offline_access", "realm-tenant-admin", "uma_authorization" ]\n  },\n  \u2026\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The value in the exp field is a JSON ",(0,i.jsx)(n.code,{children:"NumericDate"}),", which is the number of seconds (not milliseconds) since Epoch (1970-01-01T00:00:00Z UTC)."]}),"\n",(0,i.jsxs)(n.p,{children:["The following Java code snippet show how to check whether the value of ",(0,i.jsx)(n.code,{children:"exp"})," exceed current time:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'JsonNode payload = mapper.readTree (decodedAccessToken);\nif (payload.get("exp").asLong() < (System.currentTimeMillis() / 1000) ) {\n\tSystem.out.println("Not Expired.");\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},80717:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/access-token-57269d2b5f0a9b821b3c4eb9deaecc8c.png"},7649:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/postman-5d22c8b56614a9855b773538db032683.png"},65351:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/sso-session-settings-a8eb093b1b04f5c2cf64af50f2ed4475.png"},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var t=s(96540);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);